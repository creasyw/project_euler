import java.util.*;
import java.lang.*;
import java.io.*;


public class Q011To015
{
	int q011;
	int q012;
	String q013;
	long q014;
	long q015;

	public Q011To015()
	{
		q011 = question11();
		q012 = question12();
		q013 = question13();
		q014 = question14();
		q015 = question15();
	}

	// What is the greatest product of four adjacent numbers in any direction
	// (up, down, left, right, or diagonally) in the 20×20 grid (input file Q11.data)?
	// FOR READING FILE, the reading sequence is file-->buffer (read line by line)
	// -->ArrayList (read token by token)-->Integer Array (with checking)
	// The array convertion is done in question11() to avoid global variables.
	private List<List<Integer>> readFile()
	{
		List<List<Integer>> list = new ArrayList<List<Integer>>();
		try
		{
			File file = new File("Q11.data");
			FileReader reader = new FileReader(file);
			BufferedReader in = new BufferedReader(reader);
			String string;
			while((string=in.readLine())!=null)
			{
				Scanner scanner = new Scanner(string);
				List<Integer> templist = new ArrayList<Integer>();
				while(scanner.hasNextInt())
				{
					templist.add(scanner.nextInt());
				}
				list.add(templist);
			}

		}
		catch(IOException ioe)
		{
			System.out.println("Exception while reading the file: "+ioe);
		}
		return list;
	}
	private int question11()
	{
		List<List<Integer>> list = new ArrayList<List<Integer>>();
		list = readFile();
		int column = list.get(0).size();
		int row = list.size();
		Integer data[][] = new Integer[row][column];

		// convert ArrayList to array to facilitate random access
		for(int i=0; i<row; i++)
		{
			if(column!=list.get(i).size())
			{
				System.out.println("The length of array in input file is irregular..\n");
				return 0;
			}
			data[i] = list.get(i).toArray(new Integer[column]);
		}
		
		// calculate the production in FOUR directions:
		// down, right, right-down, AND left-down
		int product = 0;
		int temp;
		boolean rowflag = false, columnflag = false;
		for(int i=0;i<row;i++)
		{
			for(int j=0;j<column;j++)
			{
				if(i+3<row)
				{
					temp=data[i][j]*data[i+1][j]*data[i+2][j]*data[i+3][j];
					rowflag=true;
					product = Math.max(product,temp);
				}
				if(j+3<column)
				{
					temp=data[i][j]*data[i][j+1]*data[i][j+2]*data[i][j+3];
					columnflag=true;
					product = Math.max(product,temp);
				}
				if(rowflag && columnflag)
				{
					temp=data[i][j]*data[i+1][j+1]*data[i+2][j+2]*data[i+3][j+3];
					product = Math.max(product,temp);
				}
				if(i+3<row && j-3>=0)
				{
					temp=data[i][j]*data[i+1][j-1]*data[i+2][j-2]*data[i+3][j-3];
					product = Math.max(product,temp);
				}
				rowflag=columnflag=false;
			}
		}
		return product;
	}

	// The sequence of triangle numbers is generated by adding the natural numbers.
	// The first ten terms would be: 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
	// Let us list the factors of the first seven triangle numbers:
	//      1: 1
	//      3: 1,3
	//      6: 1,2,3,6
	//      10: 1,2,5,10
	//      15: 1,3,5,15
	//      21: 1,3,7,21
	//      28: 1,2,4,7,14,28
	// We can see that 28 is the first triangle number to have over five divisors.
	// What is the value of the first triangle number to have over five hundred divisors?
	// SOLUTION: the most elemetary means is to find every factor by i++, and count the number to 500.
	// Since it is too laborious, i prefer some other optimized way:
	// factorization-->combination into set (no duplicated elements)->count the number.
	private List<Integer> factorization(int val)
	{
		List<Integer> list = new ArrayList<Integer>();

		for(int i=2; i<=val/i; i++)
		{
			while(val%i==0)
			{
				list.add(i);
				val = val/i;
			}
		}
		if(val>1)
			list.add(val);

		return list;
	}
	// The solution could be as easy as the basic computation of 
	// premutation and combination.
	private int findFactorNumber(List<Integer> list)
	{
		int product = 1;
		int count = 1;
		int comparator, previous;
		Iterator<Integer> iterator = list.iterator();

		previous = iterator.next().intValue();
		while(iterator.hasNext())
		{
			comparator = iterator.next().intValue();
			if(comparator==previous)
				count++;
			else
			{
				product = product*(count+1);
				count = 1;
				previous = comparator;
			}
		}
		product = product*(count+1);
		return product;
	}

	private int question12()
	{
		int numOfDivisor = 498;		// exclude 1 and num itself
		int num = 1;
		int step = 1;	// beginning point is 55. step is the value of previous step.
		int count = 0;
		List<Integer> list = new ArrayList<Integer>();;
		Set<Integer> set = new HashSet<Integer>();

		while(count<numOfDivisor)
		{
			step++;
			num +=step;
			list = factorization(num);
			// check if # of potential largest combination of factors equals to 499
			// sum(choose i from m)=2^m-2  (i=1...m-1)
			// This is derived from the formula of (x+y)^m
			if((Math.pow(2,list.size())-2)<499)
				continue;
			count = findFactorNumber(list);
		}
		return num;
	}

	// Question13: Work out the first ten digits of the sum of the following one-hundred 50-digit numbers.
	// SOLUTION: because 50-digit number would make either int or long overflowed, and the final result
	// only asks for 10 digits, I just subtract the first 12 digit (actucally 10 digit might also be enough)
	// and add all 100 numbers together, then find the 10 digits as result.
	private ArrayList<Long> readDataFile()
	{
		ArrayList<Long> data = new ArrayList<Long>();
		try
		{
			File file = new File("Q13.data");
			FileReader reader = new FileReader(file);
			BufferedReader in = new BufferedReader(reader);
			String string;
			long temp;
			while((string=in.readLine())!=null)
			{
				temp = Long.valueOf(string.substring(0,12));
				data.add(temp);
			}
		}
		catch(IOException ioe)
		{
			System.out.println("Exception while reading the file: "+ioe);
		}
		return data;
	}	
	// I use String to subtract the several digits both in the main function of the function 
	// and the sub-function, because it might be the most straightforward way to do so.
	private String question13()
	{
		ArrayList<Long> data = readDataFile();
		Iterator<Long> iterator = data.iterator();
		long sum = 0;
		String result;
		while(iterator.hasNext())
			sum += iterator.next();
		result=Long.toString(sum);
		return result.substring(0,10);
	}

	// Q14: The following iterative sequence is defined for the set of positive integers:
	// n → n/2 (n is even); n → 3n + 1 (n is odd)
	// Using the rule above and starting with 13, we generate the following sequence:
	// 13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1
	// It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms.
	// Although it has not been proved yet (Collatz Problem), 
	// it is thought that all starting numbers finish at 1.
	// Which starting number, under one million, produces the longest chain?
	// SOLUTION: The Collatz conjecture has two main properties:
	// 1. no infinite trajectory occurs; 2. no cycle occurs.
	// So, if we put the trajectory into the table and make value as key,
	// there will be no duplicated keys and we can trace trajectory conjecture in O(1) in average.
	private long question14()
	{
		Map<Long,Integer> collatzRoute = new HashMap<Long,Integer>();
		ArrayList<Long> intermediate = new ArrayList<Long>();
		Iterator<Long> iterator = intermediate.iterator();
		long num = 3;
		int step = 0;
		int length;
		long temp, iter;
		long result = 0;

		// initialize the map
		collatzRoute.put((long)4,3);
		collatzRoute.put((long)2,2);
		while(num<1000000)
		{
			if(collatzRoute.containsKey(num))
			{
				num++;
				continue;
			}
			iter = num;
			intermediate.add(num);
			while(iter!=1)
			{
				if(iter%2==0)
					iter = iter/2;
				else
					iter = iter*3+1;
				if(collatzRoute.containsKey(iter))
				{
					length = intermediate.size()+collatzRoute.get(iter);
					iterator=intermediate.iterator();
					while(iterator.hasNext())
					{
						temp=iterator.next();
					// only store number under 1 million and omit those extremely
					// large and seledom met ones. Or, heap space will be run out...
						if(temp<1000000)
							collatzRoute.put(temp,length);
						length--;
					}
					intermediate.clear();
					break;
				}
				else
					intermediate.add(iter);
			}
			length = collatzRoute.get(num);
			if(length>step)
			{
				step = length;
				result = num;
			}
			num++;
		}
		return result;
	}

	// Starting in the top left corner of a 2×2 grid, there are 6 routes (without
	// backtracking--only right and dowm permitted) to the bottom right corner.
	// How many routes are there through a 20×20 grid?
	private class gridPoint{
		// x and y are the coordinates of this point
		int x;
		int y;
		long ways;
		public gridPoint(int i, int j, long k)
		{
			x = i;
			y = j;
			ways = k;
		}
		public void addWays(long n)
		{
			ways += n;
		}
	}
	private long question15()
	{
		Queue<gridPoint> queue = new LinkedList<gridPoint>();
		gridPoint[][] gridpoint = new gridPoint[21][21];
		gridPoint temp;
		for(int i=0;i<21;i++)
			for(int j=0;j<21;j++)
				gridpoint[i][j] = new gridPoint(i,j,0);
		// initial the first two points
		gridpoint[19][20].addWays(1);
		gridpoint[20][19].addWays(1);
		queue.add(gridpoint[19][20]);
		queue.add(gridpoint[20][19]);
		// loop to find the value of gridpoint[0][0]
		while(queue.element()!=gridpoint[0][0])
		{
			temp=queue.element();
			if(temp.x!=0 && temp.y!=0)
			{
				// add left child's ways
				gridpoint[temp.x-1][temp.y].addWays(temp.ways);
				// add right child's ways
				gridpoint[temp.x][temp.y-1].addWays(temp.ways);
				// remove itself from the queue
				queue.remove();
				// add left child to the queue
				queue.add(gridpoint[temp.x-1][temp.y]);
				if(temp.x==20)
					// add right child to the queue
					queue.add(gridpoint[temp.x][temp.y-1]);
			}
			else if(temp.x==0)
			{
				// add right child's ways
				gridpoint[temp.x][temp.y-1].addWays(temp.ways);
				// remove itself from the queue
				queue.remove();
			}
			else if(temp.y==0)
			{
				// add left child's ways
				gridpoint[temp.x-1][temp.y].addWays(temp.ways);
				// remove itself from the queue
				queue.remove();
				// add left child to the queue
				queue.add(gridpoint[temp.x-1][temp.y]);
			}
		}

		return gridpoint[0][0].ways;
	}


	// Main function to print out all of the results
	public static void main (String args[])
	{
		Q011To015 question = new Q011To015();
		System.out.printf("Q011: result = %d.\n", question.q011);
		System.out.printf("Q012: result = %d.\n", question.q012);
		System.out.printf("Q013: result = %s.\n", question.q013);
		System.out.printf("Q014: result = %d.\n", question.q014);
		System.out.printf("Q015: result = %d.\n", question.q015);
	}
}

