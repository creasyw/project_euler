#lang racket

;; import intlst->num
;; import num->intlst
(require "list.rkt")
;; import factors
(require "factor.rkt")

(provide factorial)
(provide decimal->binary)
(provide binary->decimal)
(provide pythagorean?)
(provide num-of-pythagorean)
(provide pandigital?)

(define (factorial n)
  (if (<= n 1) 1
      (foldl * 1 (range 2 (+ n 1)))))

(define (decimal->binary num)
  (define (helper n acc)
    (if (= n 1) (intlst->num (cons 1 acc))
        (helper (quotient n 2) (cons (remainder n 2) acc))))
  (helper num '()))

(define (binary->decimal num)
  (let ((nlst (reverse (num->intlst num))))
    (define (helper lst count acc)
      (if (null? lst) acc
          (helper (cdr lst) (+ count 1) (+ acc (* (car lst) (expt 2 count))))))
    (helper nlst 0 0)))

;; =======
;; The pythagorean is mentioned in q009, q039, and q075.
;; as stated in the Pythagorean triple @ wikipedia: 
;; "Despite generating all primitive triples, Euclid's formula does not 
;; produce all triples. This can be remedied by inserting an additional 
;; parameter k to the formula. The following will generate all 
;; Pythagorean triples uniquely:"

;; the basic way to generate Pythagorean triples is to use Euclid's formular:
;; a=m^2-n^2, b=2mn, c=m^2+n^2, where m>n.
;; a+b+c=1000 ==> m(m+n)=500 & m>0, n>0, m>n
(define (pythagorean? premeter)
  (let ((sum (/ premeter 2)))
    (and (integer? sum)
         (letrec ((factor-lst (reverse (factors sum))))
           (define (answer? m n) (and (> m 0) (> n 0) (> m n)))
           
           (define (find-product m n)
             (list (- (* m m) (* n n)) (* 2 m n) (+ (* m m) (* n n))))
           
           (define (helper lst)
             (and (not (null? lst))
                  (letrec ((m (car lst))
                           (n (- (/ sum (car lst)) m)))
                    (if (answer? m n)
                        (find-product m n)
                        (helper (cdr lst))))))
           (helper factor-lst)))))

;; because primitive pythagorean triples will be generated by copirme sides
;; (a, b, c), and (a*2, b*2, c*2)... (a*(2^k), b*(2^k), c*(2^k)), where k is
;; any integer value. Hence we can regard the coprime sides as root for one solution
;; of pythagorean triples. Then, the problem of finding pythagorean triples for a 
;; given premeter can be simplified as finding coprime pairs within the factors of
;; that premeter, which is the 2nd condition in the pattern matching.
(define (num-of-pythagorean n)
  (let ((lst (drop (factors n) 1)))
    (define (loop itr acc)
      (cond ((null? itr) (length acc))
            ((pythagorean? (car itr))
             (loop (filter (lambda (x) (not (integer? (/ (log (/ x (car itr)))
                                                         (log 2)))))
                           (cdr itr))
                   (cons (car itr) acc)))
            (#t (loop (cdr itr) acc))))
    (loop lst '())))

;; panditital number contains 1 to n exactly once.
;; this module is used in q033, q038, and q041
(define (pandigital? n)
  (letrec ((target (sort (num->intlst n) <))
           (nlist (range 1 (+ 1 (length target)))))
    (equal? target nlist)))