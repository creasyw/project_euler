#lang racket

;; import intlst->num
;; import num->intlst
;; import list-pos
;; import list-pickup
(require "list.rkt")
;; import factors
(require "factor.rkt")

(provide factorial)
(provide decimal->binary)
(provide binary->decimal)
(provide odd?)
(provide pythagorean?)
(provide num-of-pythagorean)
(provide pandigital?)
(provide palindromic?)
(provide divisible?)
(provide cyclic?)
(provide arithmetic-sequence)
(provide reverse-number)

(define (factorial n)
  (if (<= n 1) 1
      (foldl * 1 (range 2 (+ n 1)))))

(define (odd? n)
  (integer? (/ n 2)))

(define (divisible? a b)
  (integer? (/ a b)))

(define (decimal->binary num)
  (define (helper n acc)
    (if (= n 1) (intlst->num (cons 1 acc))
        (helper (quotient n 2) (cons (remainder n 2) acc))))
  (helper num '()))

(define (binary->decimal num)
  (let ((nlst (reverse (num->intlst num))))
    (define (helper lst count acc)
      (if (null? lst) acc
          (helper (cdr lst) (+ count 1) (+ acc (* (car lst) (expt 2 count))))))
    (helper nlst 0 0)))

;; =======
;; The pythagorean is mentioned in q009, q039, and q075.
;; as stated in the Pythagorean triple @ wikipedia: 
;; "Despite generating all primitive triples, Euclid's formula does not 
;; produce all triples. This can be remedied by inserting an additional 
;; parameter k to the formula. The following will generate all 
;; Pythagorean triples uniquely:"

;; the basic way to generate Pythagorean triples is to use Euclid's formular:
;; a=m^2-n^2, b=2mn, c=m^2+n^2, where m>n.
;; a+b+c=1000 ==> m(m+n)=500 & m>0, n>0, m>n
(define (pythagorean? premeter)
  (let ((sum (/ premeter 2)))
    (and (integer? sum)
         (letrec ((factor-lst (reverse (factors sum))))
           (define (answer? m n) (and (> m 0) (> n 0) (> m n)))
           
           (define (find-product m n)
             (list (- (* m m) (* n n)) (* 2 m n) (+ (* m m) (* n n))))
           
           (define (helper lst)
             (and (not (null? lst))
                  (letrec ((m (car lst))
                           (n (- (/ sum (car lst)) m)))
                    (if (answer? m n)
                        (find-product m n)
                        (helper (cdr lst))))))
           (helper factor-lst)))))

;; because primitive pythagorean triples will be generated by copirme sides
;; (a, b, c), and (a*2, b*2, c*2)... (a*(2^k), b*(2^k), c*(2^k)), where k is
;; any integer value. Hence we can regard the coprime sides as root for one solution
;; of pythagorean triples. Then, the problem of finding pythagorean triples for a 
;; given premeter can be simplified as finding coprime pairs within the factors of
;; that premeter, which is the 2nd condition in the pattern matching.
(define (num-of-pythagorean n)
  (length (candidates-of-pythagorean n)))

(define (candidates-of-pythagorean n)
  (let ((lst (drop (factors n) 1)))
    (define (loop itr acc)
      (cond ((null? itr) acc)
            ((pythagorean? (car itr))
             (loop (filter (lambda (x) (not (integer? (/ (log (/ x (car itr)))
                                                         (log 2)))))
                           (cdr itr))
                   (cons (car itr) acc)))
            (#t (loop (cdr itr) acc))))
    (loop lst '())))

;; panditital number contains 1 to n exactly once.
;; this module is used in q033, q038, and q041
(define (pandigital? n)
  (letrec ((target (sort (num->intlst n) <))
           (nlist (range 1 (+ 1 (length target)))))
    (equal? target nlist)))

;; Find consecutive longest arithmetic sequence in the given list
;; if there is none, it returns false.
;; Assuming the input list is sorted in ascending order.
(define (arithmetic-sequence lst)
  (define (helper rest result diff temp)
    (if (null? (cdr rest)) (longer result (reverse temp))
        (letrec ((new-diff (- (cadr rest) (car rest))))
          (cond ((= diff new-diff)
                 (helper (cdr rest) result diff (cons (cadr rest) temp)))
                ((and (> (length temp) 1) (> (length temp) (length result)))
                 (helper (cdr rest) (reverse temp) new-diff (reverse (take rest 2))))
                (#t (helper (cdr rest) result new-diff (reverse (take rest 2))))))))
  (if (> (length lst) 2)
      (helper (cdr lst) '() (- (cadr lst) (car lst)) (reverse (take lst 2)))
      lst))

;; required in q055
(define (palindromic? n)
  (let ((lst (num->intlst n)))
    (equal? lst (reverse lst))))

;; return the number in reverse form
(define (reverse-number n)
  (intlst->num (reverse (num->intlst n))))

;; determine if two numbers are cyclic
(define (cyclic? a b ndigits)
  (letrec ((alst (num->intlst a))
           (blst (num->intlst b)))
    (equal? (drop alst (- (length alst) ndigits)) (take blst ndigits))))