#include<stdio.h>
#include<stdlib.h>
#include<math.h>

// for question3,4
#define MAX(a,b) (a>b?a:b)


int MaxInt(int a, int b)
{
	if(a>=b)
		return a;
	else
		return b;
}

// If we list all the natural numbers below 10 that are multiples of 3 or 5,
// we get 3, 5, 6 and 9. The sum of these multiples is 23.
// Find the sum of all the multiples of 3 or 5 below 1000.
// SOLUTION: Brutal force might be a straight forward solution:)
int question1()
{
	int sum = 0;
	int i;
	for( i=1; i<1000; i++)
	{
		if(i%3==0 || i%5==0)
			sum +=i;
	}
	return sum;
}

// Each new term in the Fibonacci sequence is generated by adding the previous two terms.
// By starting with 1 and 2, the first 10 terms will be:
// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
// By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
// SOLUTION: The fibonacci sequence should be: odd, even, odd, odd, even, odd, odd, even...
// So, the sum should contains elements with index 2,5,8,11......
int question2()
{
	int sum=2;
	int fab[3]={1,2,3};	// storing the fab sequence and only add the middle to "sum"
	int index;
	int count = 3;
	while(1)
	{
		index=count%3;
		fab[index]=fab[(count+1)%3]+fab[(count+2)%3];
		if(fab[index]>4000000)
			break;
		count++;
		if(index==1)
			sum +=fab[index];
	}
	return sum;
}


// The prime factors of 13195 are 5, 7, 13 and 29.
// What is the largest prime factor of the number 600851475143 ?
// SOLUTION: There are quite a few algorithms to solve in in wiki: http://en.wikipedia.org/wiki/Integer_factorization
// However, most of them are targetting at HUGE numbers with "100 digits".
// So, considering the algorithm complexity and the input number in this puzzle,
// it might be a good trade-off to considering 3 to n^.5 without even number.
// The input for this question is: question3(3,600851475143);
// The "begin" is just a small optimization cutting running time by 67%.
long question3(long begin, long input)
{
	//int input = 600851475143;
	long square;
	long result = 0;
	long i;

	if(input==1)
		return 1;
	while(input%2==0)
		input = input/2;
	square = ceil(sqrt(input));
	for(i=begin;i<square;i+=2)
	{
		if(input%i==0){
			result = MAX(i,question3(i,ceil(input/i)));
			break;
		}
	}
	if(result==0)
		result = MAX(2,input);
	return result;
}


// A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 Ã— 99.
// Find the largest palindrome made from the product of two 3-digit numbers.
// SOLUTION: The most straight forward (but way too brutal) is to iteration two numbers from 999 to 100 and test the result.
// To improve it, we can have to input variables to limit the range of searching
// The input format for this Q should be "question4(999,100)"
// Note that I have changed the MAX macro to MaxInt function for the macro performs wierd when I recursively call the function...
int question4(int firstBegin, int lastEnd)
{
	int temp = firstBegin;
	int product = 0;
	int test1, test2, test3;
	if(firstBegin<=lastEnd)
	{
		return 0;	// branch cut.
	}
	while(1)
	{
		product = firstBegin*temp;
		if(product<100000){
			product=0;
			break;
		}
		test1 = (int)product/100000;
		if(test1==product%10)
		{
			test2=((int)product/10000)%10;
			if(test2==((int)product/10)%10)
			{
				test3=((int)product/1000)%10;
				if(test3==((int)product/100)%10)
					break;
			}
		}
		if(temp<=lastEnd)
		{
			product=0;
			break;	// cannot found
		}
		temp--;
	}
	product = MaxInt(product,(question4(firstBegin-1,temp)));
	return product;
}
// IMPROVE QUESTION4
int question4Improved()
{
	int result=0;
	int a = 999, b, db;
	int product, test1, test2, test3;
	while(a>=100)
	{
		if(a%11==0)
		{
			b=999;
			db=1;
		} else {
			b=990;
			db=11;
		}
		while(b>=a)
		{
			product=a*b;
			if(product<=result)
				break;
			// test if a*b is palindrome
			test1 = (int)product/100000;
			if(test1==product%10)
			{
				test2=((int)product/10000)%10;
				if(test2==((int)product/10)%10)
				{
					test3=((int)product/1000)%10;
					if(test3==((int)product/100)%10)
					{
						result=product;
						break;
					}
				}
			}
			b=b-db;
		}
		a--;
	}
	return result;
}


// 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
// What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
// SOLUTION: the array can be divided as 2-n^.5 and n^.5-n. For the former part, we need to know how many powers for each prime, and for the latter part, we just need to multiply all of the primes.
int question5()
{
	int range = 20;
	int square = ceil(sqrt(range));
	int n, power;
	int result = 1;
	int i, flag=0;

	// find the power from 2 to square
	for(n=2;n<square;n++)
	{
		// check if n is a prime
		for(i=2;i<=floor(sqrt(n));i++)
		{
			if(n%i==0)
			{
				flag=1;
				break;
			}
		}
		if(flag)
		{
			flag=0;
			continue;
		}
		// find how many powers are needed
		power=2;
		while(1)
		{
			if(pow(n,power)>=range)
				break;
			power++;
		}
		result = result*pow(n,(power-1));
	}
		
	// find all of the primes within the range
	for(n=square;n<range;n++)
	{
		// check if n is a prime
		for(i=2;i<=floor(sqrt(n));i++)
		{
			if(n%i==0)
			{
				flag=1;
				break;
			}
		}
		if(flag)
		{
			flag=0;
			continue;
		}
		result=result*n;
	}

	return result;
}



int main(){
	printf("result = %d.\n", question5());
	return 0;
}


